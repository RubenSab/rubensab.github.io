<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.00, maximum-scale=2.00, minimum-scale=1.00">
    <title>Discrete-State Problem Solver</title>
    <link rel="stylesheet" href="../../../style/base.css">
    <link rel="stylesheet" href="../../../style/post.css">
</head>

<body>
    <div class="container">
    	<a href="../../../index.html" class="back-link">{ Go home }</a>
		<div class="header">
	    	<div class="thumbnail">
	    		<img src="8.png" alt="Thumbnail" style="aspect-ratio: 21/9">
	    	</div>
	    	<div class="title"><h1>Designing a Discrete-State Problem Solver</h1></div>
	    	<div class="date">2025-11-16</div>
    	</div>
    	<div class="content">
    	<p>Some days ago I finally finished coding the first stable version of the interpreter for  <a href="https://github.com/RubenSab/Stackade">{ Stackade }</a>, my programming language.</p>
<p>Getting tired of testing solutions for increasingly complex and language-specific problems, a rather "simple" problem (or so I thought) piqued my interest, one of a more abstract nature.</p>
<h1>A simple problem</h1>
<p>The most natural structure you can work with in Stackade is the <strong>Stack</strong>, which is basically a <strong>pile of elements</strong> and nothing more.</p>
<p>From now on, picture it as a <strong>string</strong> like "cba", where "c" is the downmost element and "a" is the upmost, going left to right.</p>
<p>First things first, I wanted to know whether it was possible to start with the string "ab" and end with "abab" using a <strong>sequence</strong> of these three <strong>rules</strong>:</p>
<ul>
<li><code>dup</code>: duplicates the last character, so "ab" becomes "abb";</li>
<li><code>swap</code>: swaps the last character and the one before it, so "ab" becomes "ba";</li>
<li><code>rot</code>: swaps the last character with the third to last, so "abcd" becomes "adcb";</li>
</ul>
<p>How hard could it be? I thought that two or three steps could make for it, but when trying by hand, I got a solution double as long:</p>
<ol>
<li><strong>ab</strong> -&gt; ba (swap)</li>
<li>ba -&gt; baa (dup)</li>
<li>baa -&gt; aab (rot)</li>
<li>aab -&gt; aabb (dup)</li>
<li>aabb -&gt; abba (rot)</li>
<li>abba -&gt; <strong>abab</strong> (swap)</li>
</ol>
<p>My concern is not finding <em>a</em> solution for this particular problem only; I'm interested in finding <em>the</em> more efficient solution and demonstrating it's the one, for <em>any</em> instance of this kind of problems.</p>
<p>From an even broader perspective, maybe every simple enough problem definable with a "<strong>state</strong>" to <strong>reach</strong> from a <strong>starting one</strong>, plus a <strong>set of rules</strong> to go from a state to the possible next ones can be solved in the <strong>same way</strong>.</p>
<h2>The state space</h2>
<blockquote>In computer science, a state space is a discrete space representing the set of <b>all possible configurations of a system.</b></i></blockquote>
<p>For example, the "ab" -> "abab" problem lives in this "state space"<img src="state_space.png" alt="Problem's state space"> which has 3 "islands", or more appropriately <i><b>disjointed classes</b></i>, meaning that if you start from a state inside one class, you will never be able to reach your desired end if it's inside another class. For example, you can't reach "aaa" from "ab".</p>

<ul>
	<li>red arrows = <code style="color: #FA2020; font-weight: bold">dup</code> rule</li>
	<li>blue arrows = <code style="color: #2070FA; font-weight: bold">swap</code> rule</li>
	<li>green arrows = <code style="color: #46DB1D; font-weight: bold">rot</code> rule</li>
</ul>

<p>For visual clarity I have omitted the rules that produce the same state to which they are applied.</p>

<p>Now let's write strings with <b>three different letters</b> (a b and c) instead of just two and see what happens.</p>
<img src="4.png" loading="lazy" alt="3 letters making 4 long words">
<p>This state space <b>contains fully</b> the previous one (its main structure can be seen in the lower right corner), and it's more than thrice as big with the new emerging structures!</p>
<p>Notice the green and blue <b>rings</b>: they are classes made up of the longest strings possible in each iteration, where each element is linked to the next one with either <code>swap</code> or <code>rot</code>.</p>
<p>These rings <b>couldn't be made using the <code>dup</code></b> operation (shown as red arrows), because <code>dup</code></b> does not have an
<i><b>inverse operation</b></i> (at least we haven't defined one), while both <code>swap</code> and <code>rot</code> have one, <b>being the inverses of themselves</b>.</p>

<p>But what if the strings were <b>longer</b> than just 4 letters? would there be more disjointed classes, or a <b>different structure</b> altogether?
<p>Here are the state spaces for strings made with a, b, c and long <b>at most</b> 5, 6, 7 and 8 letters.
<div class="gallery">
	<img src="5.png" loading="lazy" alt="3 letters making 5 long words">
	<img src="6.png" loading="lazy" alt="3 letters making 6 long words">
	<img src="7.png" loading="lazy" alt="3 letters making 7 long words">
	<img src="8.png" loading="lazy" alt="3 letters making 8 long words">
</div>
<p>The <b>complexity increases</b> dramatically with each iteration, together with the number of <b>disjointed classes</b>.
<h1>The generic problem is a logic labyrinth</h1>
<p>As stated above, every problem compatible with our idea of solution have common features, strikingly similar to the structure of a <strong>labyrinth</strong>:</p>
<ul>
<li>a set of states (the <em>labyrinth</em>), all with the same features, for example being a string of four characters at most;</li>
<li>an <strong>initial</strong> state (the <em>entrance</em>);</li>
<li>a "<strong>solved</strong>" state (the <em>exit door</em>);</li>
<li>a set of <strong>rules</strong> to <strong>transition</strong> (the <em>corridors</em>) from a state to another. Note that some transitions (the <em>walls</em>) could be <strong>impossible</strong> to make. Think about the "ab" -&gt; "abab" example: we could not have applied <code>rot</code> to "ab", because it's only two characters long.</li>
</ul>
<p>Unsurprisingly, the simplest problem solvable with the system we are building is finding the shortest exit path of a labyrinth, provided that the map was properly encoded as a network of nodes, because there's no computation of next states involved, only the traversal of already existing ones.</p>
<h1>Coding it</h1>
<p><em>Object Oriented Programming</em> is the perfect fit for this project, because states can be build as <strong>objects</strong> storing particular data while sharing the same generic blueprint specified in their <strong>class</strong>.
On the other hand, <strong>rules</strong> can be implemented as <strong>methods</strong> that compute the next state and connect it to the previous one, growing the network.</p>
    	</div>
    </body>
</html>
